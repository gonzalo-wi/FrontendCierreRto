import axios from 'axios'

// Configuraci√≥n base de Axios - Usando proxy de Vite
const API_BASE_URL = '/api'

const apiClient = axios.create({
  baseURL: API_BASE_URL,
  timeout: 10000, 
  headers: {
    'Content-Type': 'application/json',
    'Accept': 'application/json'
  }
})

apiClient.interceptors.response.use(
  response => response,
  error => {
    console.error('Error en la petici√≥n:', error)
    return Promise.reject(error)
  }
)

/**
 * Obtiene la fecha actual en formato MM-DD-YYYY
 * @returns {string} Fecha en formato MM-DD-YYYY
 */
function getCurrentDate() {
  const today = new Date()
  const month = String(today.getMonth() + 1).padStart(2, '0')
  const day = String(today.getDate()).padStart(2, '0')
  const year = today.getFullYear()
  return `${month}-${day}-${year}`
}

/**
 * Simula los montos esperados para La Plata
 * @returns {Object} Montos esperados por RTO
 */
function getExpectedAmountsLaPlata() {
  return {
    'RTO_01': 50000,
    'RTO_02': 75000,
    'RTO_03': 60000,
    'RTO_04': 80000,
    'RTO_05': 45000,
    'RTO_06': 70000,
    'RTO_07': 55000,
    'RTO_08': 65000
  }
}

export default {
  /**
   * Obtiene los dep√≥sitos de La Plata desde la API real
   * @param {string} date - Fecha en formato MM-DD-YYYY (opcional, por defecto fecha actual)
   * @returns {Promise} Datos de dep√≥sitos agrupados por RTO
   */
  async getDeposits(date = null) {
    try {
      // Si no se proporciona fecha, usar la fecha actual
      const selectedDate = date || getCurrentDate()
      
      console.log(`[La Plata] Obteniendo dep√≥sitos para la fecha: ${selectedDate}`)
      
      const response = await apiClient.get(`/deposits/plata?date=${selectedDate}`)
      
      console.log(`[La Plata] Respuesta de la API:`, response.data)
      
      // Transformar los datos de la API para agrupar por RTO
      const rtoSummary = {}
      
      // Procesar cada dep√≥sito de la respuesta
      if (response.data && Array.isArray(response.data)) {
        response.data.forEach(deposit => {
          const rtoCode = deposit.rto_code || deposit.rto || 'UNKNOWN'
          const amount = parseFloat(deposit.amount || deposit.monto || 0)
          
          if (rtoSummary[rtoCode]) {
            rtoSummary[rtoCode] += amount
          } else {
            rtoSummary[rtoCode] = amount
          }
        })
      }
      
      // Obtener montos esperados (simulados por ahora)
      const expectedAmounts = getExpectedAmountsLaPlata()
      
      // Crear estructura de datos final
      const repartos = []
      
      // Agregar RTOs que tienen dep√≥sitos reales
      Object.keys(rtoSummary).forEach(rtoCode => {
        repartos.push({
          id: rtoCode,
          nombre: `Reparto ${rtoCode}`,
          montoEsperado: expectedAmounts[rtoCode] || 0,
          montoReal: rtoSummary[rtoCode],
          diferencia: rtoSummary[rtoCode] - (expectedAmounts[rtoCode] || 0),
          porcentajeEjecucion: expectedAmounts[rtoCode] ? 
            ((rtoSummary[rtoCode] / expectedAmounts[rtoCode]) * 100).toFixed(2) : 0,
          estado: 'completado',
          fecha: selectedDate,
          movimientos: [{
            tipo: 'dep√≥sito',
            monto: rtoSummary[rtoCode],
            descripcion: `Dep√≥sito real del ${selectedDate}`,
            fecha: selectedDate
          }]
        })
      })
      
      // Agregar RTOs esperados que no tienen dep√≥sitos
      Object.keys(expectedAmounts).forEach(rtoCode => {
        if (!rtoSummary[rtoCode]) {
          repartos.push({
            id: rtoCode,
            nombre: `Reparto ${rtoCode}`,
            montoEsperado: expectedAmounts[rtoCode],
            montoReal: 0,
            diferencia: -expectedAmounts[rtoCode],
            porcentajeEjecucion: 0,
            estado: 'pendiente',
            fecha: selectedDate,
            movimientos: []
          })
        }
      })
      
      console.log(`[La Plata] Datos procesados:`, repartos)
      
      return {
        success: true,
        data: repartos,
        fecha: selectedDate,
        total: repartos.length
      }
      
    } catch (error) {
      console.error('[La Plata] Error al obtener dep√≥sitos:', error)
      
      // Fallback a datos simulados en caso de error
      console.log('[La Plata] Usando datos simulados como fallback')
      return this.getSimulatedData(date)
    }
  },

  /**
   * M√©todo principal para obtener repartos (wrapper para compatibilidad)
   * @param {string} date - Fecha en formato MM-DD-YYYY (opcional)
   * @returns {Promise} 
   */
  async getRepartos(date = null) {
    const result = await this.getDeposits(date)
    return result.data
  },

  /**
   * Obtiene la fecha actual en formato MM-DD-YYYY
   * @returns {string} Fecha en formato MM-DD-YYYY
   */
  getFechaActual() {
    const hoy = new Date()
    const mes = String(hoy.getMonth() + 1).padStart(2, '0')
    const dia = String(hoy.getDate()).padStart(2, '0')
    const a√±o = hoy.getFullYear()
    return `${mes}-${dia}-${a√±o}`
  },

  /**
   * Transforma los datos de la API al formato esperado por el frontend
   * @param {Object} apiData - Datos de la API
   * @param {string} fecha - Fecha de consulta
   * @returns {Array} Array de repartos transformados
   */
  async transformApiDataToRepartos(apiData, fecha) {
    const repartos = []
    
    // Obtener montos esperados para esta fecha
    const montosEsperados = await this.getMontoEsperadoPorReparto(fecha)
    
    // Iterar sobre cada identificador (L-EJU-003, etc.)
    Object.keys(apiData).forEach(identifier => {
      const depositData = apiData[identifier]
      
      // Verificar si tiene la estructura ArrayOfWSDepositsByDayDTO
      if (depositData.ArrayOfWSDepositsByDayDTO && depositData.ArrayOfWSDepositsByDayDTO.WSDepositsByDayDTO) {
        const deposits = depositData.ArrayOfWSDepositsByDayDTO.WSDepositsByDayDTO
        
        // Asegurar que deposits sea un array
        const depositsArray = Array.isArray(deposits) ? deposits : [deposits]
        
        // Agrupar por userName para obtener repartos √∫nicos
        const repartosPorUsuario = {}
        
        depositsArray.forEach(deposit => {
          // Extraer n√∫mero de reparto del userName (ej: "RTO 273, 273" -> "273")
          const userNameMatch = deposit.userName.match(/RTO\s+(\d+)/)
          const numeroReparto = userNameMatch ? userNameMatch[1] : deposit.userName
          
          const repartoKey = `RTO-${numeroReparto}`
          
          if (!repartosPorUsuario[repartoKey]) {
            repartosPorUsuario[repartoKey] = {
              id: `${identifier}-${numeroReparto}`,
              idReparto: repartoKey,
              fechaReparto: fecha,
              numeroReparto: numeroReparto,
              userName: deposit.userName,
              identifier: identifier,
              posName: deposit.posName,
              stName: deposit.stName,
              entityName: deposit.entityName,
              depositoReal: 0,
              depositoEsperado: montosEsperados[repartoKey] || 0,
              diferencia: 0,
              estado: 'PENDIENTE',
              movimientoFinanciero: null,
              deposits: []
            }
          }
          
          // Sumar el monto del dep√≥sito
          const amount = parseFloat(deposit.currencies.WSDepositCurrency.totalAmount) || 0
          repartosPorUsuario[repartoKey].depositoReal += amount
          repartosPorUsuario[repartoKey].deposits.push(deposit)
        })
        
        // Calcular diferencia y estado para cada reparto
        Object.values(repartosPorUsuario).forEach(reparto => {
          reparto.diferencia = reparto.depositoReal - reparto.depositoEsperado
          
          if (reparto.diferencia === 0) {
            reparto.estado = 'EXACTO'
          } else if (reparto.diferencia > 0) {
            reparto.estado = 'SOBRANTE'
          } else {
            reparto.estado = 'FALTANTE'
          }
          
          repartos.push(reparto)
        })
      }
    })
    
    return repartos.sort((a, b) => a.numeroReparto.localeCompare(b.numeroReparto))
  },

  /**
   * Obtiene los montos esperados para los repartos de La Plata
   * @param {string} date - Fecha en formato MM-DD-YYYY
   * @returns {Promise} 
   */
  async getMontoEsperadoPorReparto(date) {
    try {
      // Por ahora retornar valores simulados por reparto, esto deber√≠a venir de otro endpoint
      // TODO: Implementar endpoint real para montos esperados de La Plata
      console.log('üìã Obteniendo montos esperados de La Plata para fecha:', date)
      
      // Montos esperados simulados basados en los RTOs reales de La Plata (rango 240-281)
      const montosEsperados = {
        'RTO-240': 35000,
        'RTO-242': 245000,
        'RTO-251': 450000,
        'RTO-252': 450000,
        'RTO-253': 450000,
        'RTO-254': 300000,
        'RTO-255': 520000,
        'RTO-256': 440000,
        'RTO-257': 495000,
        'RTO-258': 735000,
        'RTO-259': 385000,
        'RTO-260': 315000,
        'RTO-261': 385000,
        'RTO-262': 325000,
        'RTO-263': 535000,
        'RTO-264': 385000,
        'RTO-265': 325000,
        'RTO-266': 305000,
        'RTO-267': 295000,
        'RTO-268': 440000,
        'RTO-269': 690000,
        'RTO-270': 320000,
        'RTO-271': 535000,
        'RTO-272': 390000,
        'RTO-273': 345000,
        'RTO-274': 265000,
        'RTO-275': 245000,
        'RTO-276': 475000,
        'RTO-277': 130000,
        'RTO-278': 340000,
        'RTO-279': 295000,
        'RTO-280': 315000,
        'RTO-281': 355000
      }
      
      console.log('‚úÖ Montos esperados de La Plata obtenidos para', Object.keys(montosEsperados).length, 'RTOs')
      
      return montosEsperados
    } catch (error) {
      console.error('‚ùå Error al obtener montos esperados de La Plata:', error)
      return {}
    }
  },

  /**
   * Obtiene un reparto espec√≠fico de La Plata
   * @param {string} idReparto 
   * @returns {Promise} 
   */
  async getRepartoById(idReparto) {
    try {
      const response = await apiClient.get(`/repartos/laplata/${idReparto}`)
      return response.data
    } catch (error) {
      console.error(`Error al obtener reparto ${idReparto} de La Plata:`, error)
      throw error
    }
  },

  /**
   * Actualiza un reparto de La Plata
   * @param {string} idReparto 
   * @param {Object} repartoData 
   * @returns {Promise} 
   */
  async updateReparto(idReparto, repartoData) {
    try {
      const response = await apiClient.put(`/repartos/laplata/${idReparto}`, repartoData)
      return response.data
    } catch (error) {
      console.error(`Error al actualizar reparto ${idReparto} de La Plata:`, error)
      throw error
    }
  },

  /**
   * Crea un nuevo reparto de La Plata
   * @param {Object} repartoData - Datos del nuevo reparto
   * @returns {Promise} Promesa con el reparto creado
   */
  async createReparto(repartoData) {
    try {
      const response = await apiClient.post('/repartos/laplata', repartoData)
      return response.data
    } catch (error) {
      console.error('Error al crear reparto de La Plata:', error)
      throw error
    }
  },

  /**
   * Elimina un reparto de La Plata
   * @param {string} idReparto - ID del reparto a eliminar
   * @returns {Promise} Promesa con la confirmaci√≥n de eliminaci√≥n
   */
  async deleteReparto(idReparto) {
    try {
      const response = await apiClient.delete(`/repartos/laplata/${idReparto}`)
      return response.data
    } catch (error) {
      console.error(`Error al eliminar reparto ${idReparto} de La Plata:`, error)
      throw error
    }
  },

  /**
   * Obtiene repartos de La Plata filtrados por fecha
   * @param {string} fecha 
   * @returns {Promise} 
   */
  async getRepartosByFecha(fecha) {
    try {
      const response = await apiClient.get(`/repartos/laplata?fecha=${fecha}`)
      return response.data
    } catch (error) {
      console.error(`Error al obtener repartos de La Plata por fecha ${fecha}:`, error)
      throw error
    }
  },

  /**
   * Crea un movimiento financiero para un reparto de La Plata
   * @param {string} idReparto - ID del reparto
   * @param {Object} movimientoData - Datos del movimiento financiero
   * @returns {Promise} Promesa con el movimiento creado
   */
  async createMovimientoFinanciero(idReparto, movimientoData) {
    try {
      const response = await apiClient.post(`/repartos/laplata/${idReparto}/movimiento`, movimientoData)
      return response.data
    } catch (error) {
      console.error(`Error al crear movimiento para reparto ${idReparto} de La Plata:`, error)
      throw error
    }
  },

  /**
   * Actualiza un movimiento financiero de un reparto de La Plata
   * @param {string} idReparto - ID del reparto
   * @param {Object} movimientoData - Datos del movimiento financiero
   * @returns {Promise} Promesa con el movimiento actualizado
   */
  async updateMovimientoFinanciero(idReparto, movimientoData) {
    try {
      const response = await apiClient.put(`/repartos/laplata/${idReparto}/movimiento`, movimientoData)
      return response.data
    } catch (error) {
      console.error(`Error al actualizar movimiento para reparto ${idReparto} de La Plata:`, error)
      throw error
    }
  },

  /**
   * Elimina un movimiento financiero de un reparto de La Plata
   * @param {string} idReparto - ID del reparto
   * @returns {Promise} Promesa con la confirmaci√≥n de eliminaci√≥n
   */
  async deleteMovimientoFinanciero(idReparto) {
    try {
      const response = await apiClient.delete(`/repartos/laplata/${idReparto}/movimiento`)
      return response.data
    } catch (error) {
      console.error(`Error al eliminar movimiento para reparto ${idReparto} de La Plata:`, error)
      throw error
    }
  },

  /**
   * Obtiene los dep√≥sitos de La Plata desde la API real
   * @param {string} date - Fecha en formato MM-DD-YYYY (opcional, por defecto fecha actual)
   * @returns {Promise} Datos de dep√≥sitos agrupados por RTO
   */
  async getDeposits(date = null) {
    try {
      // Si no se proporciona fecha, usar la fecha actual
      const selectedDate = date || this.getFechaActual()
      
      console.log(`[La Plata] Obteniendo dep√≥sitos para la fecha: ${selectedDate}`)
      
      const response = await apiClient.get(`/deposits/plata?date=${selectedDate}`)
      
      console.log(`[La Plata] Respuesta de la API:`, response.data)
      
      // Transformar los datos de la API para agrupar por RTO
      const rtoSummary = {}
      
      // Procesar cada dep√≥sito de la respuesta
      if (response.data && Array.isArray(response.data)) {
        response.data.forEach(deposit => {
          const rtoCode = deposit.rto_code || deposit.rto || 'UNKNOWN'
          const amount = parseFloat(deposit.amount || deposit.monto || 0)
          
          if (rtoSummary[rtoCode]) {
            rtoSummary[rtoCode] += amount
          } else {
            rtoSummary[rtoCode] = amount
          }
        })
      }
      
      // Obtener montos esperados (simulados por ahora)
      const expectedAmounts = this.getExpectedAmountsLaPlata()
      
      // Crear estructura de datos final
      const repartos = []
      
      // Agregar RTOs que tienen dep√≥sitos reales
      Object.keys(rtoSummary).forEach(rtoCode => {
        repartos.push({
          id: rtoCode,
          nombre: `Reparto ${rtoCode}`,
          montoEsperado: expectedAmounts[rtoCode] || 0,
          montoReal: rtoSummary[rtoCode],
          diferencia: rtoSummary[rtoCode] - (expectedAmounts[rtoCode] || 0),
          porcentajeEjecucion: expectedAmounts[rtoCode] ? 
            ((rtoSummary[rtoCode] / expectedAmounts[rtoCode]) * 100).toFixed(2) : 0,
          estado: 'completado',
          fecha: selectedDate,
          movimientos: [{
            tipo: 'dep√≥sito',
            monto: rtoSummary[rtoCode],
            descripcion: `Dep√≥sito real del ${selectedDate}`,
            fecha: selectedDate
          }]
        })
      })
      
      // Agregar RTOs esperados que no tienen dep√≥sitos
      Object.keys(expectedAmounts).forEach(rtoCode => {
        if (!rtoSummary[rtoCode]) {
          repartos.push({
            id: rtoCode,
            nombre: `Reparto ${rtoCode}`,
            montoEsperado: expectedAmounts[rtoCode],
            montoReal: 0,
            diferencia: -expectedAmounts[rtoCode],
            porcentajeEjecucion: 0,
            estado: 'pendiente',
            fecha: selectedDate,
            movimientos: []
          })
        }
      })
      
      console.log(`[La Plata] Datos procesados:`, repartos)
      
      return {
        success: true,
        data: repartos,
        fecha: selectedDate,
        total: repartos.length
      }
      
    } catch (error) {
      console.error('[La Plata] Error al obtener dep√≥sitos:', error)
      
      // Fallback a datos simulados en caso de error
      console.log('[La Plata] Usando datos simulados como fallback')
      return this.getSimulatedData(date)
    }
  },

  /**
   * Datos simulados para fallback
   * @param {string} date - Fecha seleccionada
   * @returns {Object} Datos simulados
   */
  getSimulatedData(date = null) {
    const selectedDate = date || this.getFechaActual()
    const expectedAmounts = this.getExpectedAmountsLaPlata()
    
    const repartos = Object.keys(expectedAmounts).map(rtoCode => ({
      id: rtoCode,
      nombre: `Reparto ${rtoCode}`,
      montoEsperado: expectedAmounts[rtoCode],
      montoReal: Math.floor(expectedAmounts[rtoCode] * (0.8 + Math.random() * 0.4)), // 80-120% del esperado
      diferencia: 0,
      porcentajeEjecucion: 0,
      estado: 'simulado',
      fecha: selectedDate,
      movimientos: []
    }))
    
    // Calcular diferencias y porcentajes
    repartos.forEach(reparto => {
      reparto.diferencia = reparto.montoReal - reparto.montoEsperado
      reparto.porcentajeEjecucion = ((reparto.montoReal / reparto.montoEsperado) * 100).toFixed(2)
    })
    
    return {
      success: true,
      data: repartos,
      fecha: selectedDate,
      total: repartos.length,
      isSimulated: true
    }
  },

  /**
   * Obtiene los montos esperados para La Plata
   * @returns {Object} Montos esperados por RTO
   */
  getExpectedAmountsLaPlata() {
    return {
      'RTO_01': 50000,
      'RTO_02': 75000,
      'RTO_03': 60000,
      'RTO_04': 80000,
      'RTO_05': 45000,
      'RTO_06': 70000,
      'RTO_07': 55000,
      'RTO_08': 65000
    }
  }
}
